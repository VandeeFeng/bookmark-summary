# How Much Memory Do You Need in 2024 to Run 1 Million Concurrent Tasks?
- URL: https://hez2010.github.io/async-runtimes-benchmarks-2024/
- Added At: 2024-11-30 05:26:04
- [Link To Text](2024-11-30-how-much-memory-do-you-need-in-2024-to-run-1-million-concurrent-tasks_raw.md)

## Summary
**摘要**：
这篇文章主要是关于比较不同编程语言在实现1百万个并发任务时的内存消耗。在2024年底，作者再次进行了基准测试，比较了不同语言在并发执行任务时的性能变化。测试环境包括最新的硬件设备（13th Gen Intel(R) Core(TM) i7-13700K）和操作系统（Debian GNU/Linux 12）等。

**要点总结**：
1. **静态编译语言**：在实现大量并发任务时，例如进程控制、协程等概念，协程的支持使得Rust和C# (使用NativeAOT)展现出了较小的内存消耗。这类语言静态编译成本机二进制，对自身实现有较好的内存控制。

2. **内存消耗**：在不同的并发任务数量下（比如10K、100K和100万个任务），内存消耗出现了显著变化。以Rust为代表的部分静态编译语言表现优势明显，而高级语言如Java（通过GraalVM运行）和C#表现出超越预期的内存效率，成本更加合理。

3. **性能超常**：当并发任务量增加到100万个时，C#显示出显著的优势，运行内存消耗较低且在所有测试语言中击败了其他语言，包括内存消耗通常被认为较高的Java版本（使用GraalVM运行）。C#已展现出极高的竞争力和出色的内存效率。

4. **Go的局限性**：尽管Go的协程最初被认为较为健壮且效率高，但其内存消耗远超过静态编译的语言。当并发任务量增大时，Go的表现不如Java与使用GraalVM运行的Java版本、C#和NodeJS。

5. **改进与发现**：在新测试中，加入了一个from `join_all`到使用循环遍历`Vec`的测试用例，这使得Rust实现了更小的内存消耗，并最终成为测试中的领导者。这种优化方式对于动态语言Rust来说是关键进步。

**关键发现**：
- 高并发任务执行时，选择语言对内存消耗有显著影响。适合瓶颈场景的语言表现出更好的内存控制性。
- 高级语言如C#和以静态编译为主的语言如Rust，在大规模并发任务的内存消耗上取得突破性成果，提高了市场整体性能表现。
- 经过性能优化后，选择不同的库和实现方式（如C++协程的Rust-to-vec迭代替代`join_all`）对于提高内存效率有显著帮助。
