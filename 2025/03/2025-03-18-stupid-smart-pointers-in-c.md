# Stupid Smart Pointers in C
- URL: https://blog.kevinalbs.com/stupid_smart_pointers
- Added At: 2025-03-18 02:31:43
- [Link To Text](2025-03-18-stupid-smart-pointers-in-c_raw.md)

## Summary
**摘要**：
本文展示了一个C语言中智能指针的概念验证实现，用于简化C语言中的内存管理。C语言需要手动使用`malloc`和`free`进行内存分配和释放，容易导致内存泄漏。C++通过`std::unique_ptr`等智能指针解决了这个问题。本文通过修改函数调用栈的返回地址，实现了一个`free_on_exit`函数，该函数在函数返回时自动释放之前分配的内存，类似于C++的智能指针。文章详细解释了32位x86架构下的调用栈结构，展示了如何使用内联汇编来修改栈上的返回地址，以及如何通过一个`trampoline`函数来恢复原始的返回地址，避免程序出错。最终实现了一个可以多次调用的`free_on_exit`函数，通过维护一个栈来跟踪每次函数调用中分配的指针，并在函数返回时释放这些指针。虽然这个智能指针实现并不完整，但它展示了在C语言中实现类似智能指针的可能性。

**要点总结**：
1.  **C语言内存管理的挑战**：C语言中手动内存分配和释放容易出错，导致内存泄漏，尤其是在复杂的函数调用和错误处理中，需要一种机制来自动管理内存。
2.  **通过修改调用栈实现智能指针**：通过内联汇编修改函数调用栈上的返回地址，使函数返回时先执行自定义的释放内存的函数，然后才返回到原始的调用者，从而实现类似智能指针的功能。
3.  **32位x86架构调用栈**：理解32位x86架构下的调用栈结构是实现智能指针的关键，包括`ebp`（栈基指针）和`eip`（指令指针）的作用，以及函数调用时栈的变化。
4.  **Trampoline函数的必要性**：为了避免修改返回地址后程序出错，需要一个`trampoline`函数来恢复原始的返回地址，确保程序能够正常执行。`trampoline`函数作为一个中间跳转点，先调用内存释放函数，然后跳转回原始的返回地址。
5.  **多指针管理栈**：为了支持在同一个函数中多次调用`free_on_exit`，需要维护一个栈来跟踪每次调用中分配的指针，并在函数返回时释放这些指针。栈的每个条目包含调用者的`ebp`、原始的返回`eip`以及跟踪的指针列表。

